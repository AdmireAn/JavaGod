## 1.性能优化
            
**1.1 使用单例**
    
    * 使用Future模式
    
    * 使用线程池
    
    * 选择就绪
    
    * 减少上下文切换
    
    * 减少锁粒度
    
    * 数据压缩
    
    * 结果缓存
    
    * Stream并行流
     
    * GC调优
     
    * JVM内存分配调优
     
    * SQL调优
    
* * *
## 2.线上问题分析
        
#### 2.1 dump
        
**2.1.1线程Dump**
首先用命令jps -v拿到应用的pid，
```java
app@bjxg-vd-202-141:~$ jps -v
168 QuoteReceiveApplication -Xmx8g -Xms8g ......
```
168是本应用的pid
然后用命令jstack 168 >> /tmp/mydumps.stack
```java
app@bjxg-vd-202-141:~$ jstack PID >> /tmp/mydumps.tdump
```
       
**2.1.2内存Dump**
命令:
jmap -dump:format=b,file=/tmp/dump.map [pid]

**2.1.3gc情况**
gc.log上传分析：
https://gceasy.io/  
#### 2.2dump获取及分析工具
        
**2.2.1jstack**
        
**2.2.2jstat**
        
**2.2.3jmap**

**2.2.4jhat**
        
**2.2.5Arthas**
        
#### 2.3dump分析死锁
上传栈dump到
https://gceasy.io/
#### 2.4dump分析内存泄露
MAT工具分析

#### 2.5自己编写各种outofmemory，stackoverflow程序
        
**2.5.1HeapOutOfMemory**     
```java
public static void main(String[] args) {
    int len = Integer.MAX_VALUE -4;
    int largArray[] = new int[len];
    system.out.print(len);
}
```
2147483647 X 4B(一个int大小)/1024/1024 = 8192M 即需要8G内存。
如果vm参数 -Xmx<8192M,则会抛出如下异常
```
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
```
**2.5.2Young OutOfMemory**
>-XX:MaxTenuringThreshold=3
>该参数主要是控制新生代需要经历多少次GC晋升到老年代中的最大阈值。
>在JVM中用4个bit存储（放在对象头中），所以其最大值是15。
>但并非意味着，对象必须要经历15次YGC才会晋升到老年代中。
>例如，当survivor区空间不够时，便会提前进入到老年代中，但这个次数一定不大于设置的最大阈值。

所以，可以调大MaxTenuringThreshold，使得年轻代无法进入老年代而Young OutOfMemory


**2.5.3MethodArea OutOfMemory**
>在经常生成大量Class的应用中，需要特别注意类的回收状况。
>这类场景除了使用CGLib字节码增强和动态语言之外，常见的还有：大量JSP或动态产生JSP文件的应用
>（JSP第一次运行时，需要编译成Java类）、基于OSGi的应用（即使是同一个类文件，被不同的类加载器加载也会视为不同的类）等。
        
**2.5.4ConstantPool OutOfMemory**
 一般来说不可能。除非静态变量太多，或者-Xss太小       
**2.5.5DirectMemory OutOfMemory**
```java
package com.test;
 
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
 
public class Demo {
    public static void main(String[] args) throws Exception {
        List<ByteBuffer> buffers = new ArrayList<>();
        while( true ) {
            ByteBuffer buffer = ByteBuffer.allocate(1024 * 1024 * 1024);
            buffers.add(buffer);
        }
    }
}


```
        
**2.5.6Stack OutOfMemory Stack OverFlow**
    
```java
package com.test;
 
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.List;
 
public class Demo {
    public static void main(String[] args) throws Exception {
        new Demo().mtd();
    }
 
    public void mtd() {
        long time = System.currentTimeMillis();
        mtd();
    }
}


```
    
#### 2.6Arthas
>文档地址：https://alibaba.github.io/arthas/quick-start.html
>启动Arthas:
>curl -O https://alibaba.github.io/arthas/arthas-boot.jar
java -jar arthas-boot.jar


**2.6.1jvm相关**
        
**2.6.2class/classloader相关**
        
**2.6.3monitor/watch/trace相关**
        
**2.6.4options**
        
**2.6.5管道**
        
**2.6.6后台异步任务**
        
#### 2.7常见问题解决思路
        
**2.7.1内存溢出**
        
**2.7.2线程死锁**
        
**2.7.3类加载冲突**
        
**2.7.4load飙高**
        
**2.7.5CPU利用率飙高**
        
**2.7.6慢SQL**
        
#### 2.8使用工具尝试解决以下问题，并写下总结
        
**2.8.1当一个Java程序响应很慢时如何查找问题**
>1.利用arthas绘制火焰图，分析时间消耗在程序的哪个位置
2.利用arthas的trace命令，分析具体哪个方法调用慢
3.分析内存是否够用，命令：jstat -gc pid

**2.8.2当一个Java程序频繁FullGC时如何解决问题**
>1.排查是否由System.gc()引起
>2.查看内存分配是不是太小，命令：jstat -gc pid
>3.java.lang.OutOfMemoryError: Java heap space ，如果是这个异常，要看老年代是否太小
>4.java.lang.OutOfMemoryError: PermGen space ，这个异常，是永久代太小
>5.频繁full gc，说明内存通过普通gc无法回收，排查是否有内存泄漏，dump堆，用mat工具分析
>6.是否有使用大对象，比如大的数组，需要占用连续的内存空间
        
**2.8.3如何查看垃圾回收日志**
>1.[CMS日志](https://www.jianshu.com/p/ba768d8e9fec)
        
**2.8.4当一个Java应用发生OutOfMemory时该如何解决**
-XX:+HeapDumpOnOutOfMemoryError：当oom时自动打印堆栈

>1.HeapOutOfMemory
2.Young OutOfMemory
3.MethodArea OutOfMemory
4.ConstantPool OutOfMemory
5.DirectMemory OutOfMemory
        
**2.5.6Stack OutOfMemory Stack OverFlow**

        
**2.8.5如何判断是否出现死锁**
        
**2.8.6如何判断是否存在内存泄露**
        
**2.8.7使用Arthas快速排查Spring Boot应用404/401问题**
        
**2.8.8使用Arthas排查线上应用日志打满问题**
        
**2.8.9利用Arthas排查Spring Boot应用NoSuchMethodError**